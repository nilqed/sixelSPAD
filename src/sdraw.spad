)abbrev package SDRAW SaveDraw
++ Author: Kurt Pagani <nilqed@gmail.com>
++ Date Created: 13 October 2016
++ Basic Operations: sdraw
SaveDraw():
 Exports == Implementation where 
  STR  ==> String
  V2D  ==> TwoDimensionalViewport
  V3D  ==> ThreeDimensionalViewport
  G    ==> GraphImage
  DROP ==> DrawOption
  
  SPACE3 ==> ThreeSpace(DoubleFloat)
  

  Exports ==> with

    writeViewport2D : V2D -> STR
    writeViewport2D : (G, List DROP) -> STR 
    writeViewport3D : V3D -> STR
    writeViewport3D : (SPACE3, STR)-> STR 
    writeViewport3D : (SPACE3, List DROP) -> STR 
    
    
  Implementation ==> add
  
    import from TwoDimensionalViewport
    import from ThreeDimensionalViewport
    import from GraphImage
    import from SPACE3
    
    writeViewport2D(g : G, opts : List DROP):STR ==
      viewport:= viewport2D()$V2D
      putGraph(viewport,g,1)
      options(viewport,opts)
      --write(viewport,"SDATA",["pixmap","bitmap","postscript","image"])
      ----write(makeViewport2D(viewport),"SDATA")$V2D -- ok
      filename:String:="sdraw.dat"
      f1:TextFile:=open(filename::FileName,"output")
      p2 := pointLists(g)
      for p1 in p2 repeat
        for p in p1 repeat
          writeLine!(f1,concat([unparse(convert(p.1)@InputForm)," ",
                              unparse(convert(p.2)@InputForm)]))
        writeLine!(f1); -- blank line need to mark a "branch"
      close! f1
      filename
      
    writeViewport2D(v:V2D):STR ==
      --write(v,"SDATA",["pixmap","bitmap","postscript","image"])
      write(v,"SDATA")$V2D

    writeViewport3D(space : SPACE3, Title : STR) : STR ==
      v := viewport3D()$V3D
      subspace(v,space)$V3D
      options(v,[title(Title)])
      write(v,"SDATA",["pixmap","bitmap","postscript","image"])$V3D

    writeViewport3D(space : SPACE3, opts : List DROP) : STR ==
      v := viewport3D()$V3D
      subspace(v,space)$V3D
      options(v,opts)
      write(v,"SDATA",["pixmap","bitmap","postscript","image"])$V3D
       

)abbrev package SDCFUN STopLevelDrawFunctionsForCompiledFunctions
++ Author: Clifton J. Williamson
++ Date Created: 22 June 1990
++ Basic Operations: sdraw, recolor
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: STopLevelDrawFunctionsForCompiledFunctions provides top level
++ functions for drawing graphics of expressions.
STopLevelDrawFunctionsForCompiledFunctions():
 Exports == Implementation where
  ANY1 ==> AnyFunctions1
  B    ==> Boolean
  F    ==> Float
  L    ==> List
  SEG  ==> Segment Float
  SF   ==> DoubleFloat
  DROP ==> DrawOption
  PLOT ==> Plot
  PPC  ==> ParametricPlaneCurve(SF -> SF)
  PSC  ==> ParametricSpaceCurve(SF -> SF)
  PSF  ==> ParametricSurface((SF, SF) -> SF)
  Pt   ==> Point SF
  PSFUN ==> (SF, SF) -> Pt
  PCFUN ==> SF -> Pt
  SPACE3 ==> ThreeSpace(SF)
  VIEW2 ==> String
  VIEW3 ==> String
  SDRAW ==> SaveDraw

  Exports ==> with

--% Two Dimensional Function Plots

    sdraw : (SF -> SF, SEG, L DROP) -> VIEW2
      ++ sdraw(f, a..b, l) draws the graph of \spad{y = f(x)} as x
      ++ ranges from \spad{min(a, b)} to \spad{max(a, b)}.
      ++ The options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    sdraw : (SF -> SF, SEG) -> VIEW2
      ++ sdraw(f, a..b) draws the graph of \spad{y = f(x)} as x
      ++ ranges from \spad{min(a, b)} to \spad{max(a, b)}.
    makeObject : (SF -> SF, SEG, L DROP) -> GraphImage
      ++ makeObject(f, a..b, l) creates the graph of \spad{y = f(x)} as x
      ++ ranges from \spad{min(a, b)} to \spad{max(a, b)}.
      ++ The options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.

--% Parametric Plane Curves

    sdraw : (PPC, SEG, L DROP) -> VIEW2
      ++ sdraw(curve(f, g), a..b, l) draws the graph of the parametric
      ++ curve \spad{x = f(t), y = g(t)} as t ranges from \spad{min(a, b)} to
      ++ \spad{max(a, b)}.
      ++ The options contained in the list l of the domain \spad{DrawOption}
      ++ are applied.
    sdraw : (PPC, SEG) -> VIEW2
      ++ sdraw(curve(f, g), a..b) draws the graph of the parametric
      ++ curve \spad{x = f(t), y = g(t)} as t ranges from \spad{min(a, b)} to
      ++ \spad{max(a, b)}.
    makeObject : (PPC, SEG, L DROP) -> GraphImage
      ++ makeObject(curve(f, g), a..b, l) creates the graph of the parametric
      ++ curve \spad{x = f(t), y = g(t)} as t ranges from \spad{min(a, b)} to
      ++ \spad{max(a, b)}.
      ++ The options contained in the list l of the domain \spad{DrawOption}
      ++ are applied.

--% Parametric Space Curves

    sdraw : (PSC, SEG, L DROP) -> VIEW3
      ++ sdraw(curve(f, g, h), a..b, l) draws the graph of the parametric
      ++ curve \spad{x = f(t), y = g(t), z = h(t)} as t ranges from
      ++ \spad{min(a, b)} to \spad{max(a, b)}.
      ++ The options contained in the list l of the domain
      ++ \spad{DrawOption} are applied.
    sdraw : (PSC, SEG) -> VIEW3
      ++ sdraw(curve(f, g, h), a..b, l) draws the graph of the parametric
      ++ curve \spad{x = f(t), y = g(t), z = h(t)} as t ranges from
      ++ \spad{min(a, b)} to \spad{max(a, b)}.
    sdraw : (PCFUN, SEG, L DROP) -> VIEW3
      ++ sdraw(f, a..b, l) draws the graph of the parametric
      ++ curve \spad{f} as t ranges from
      ++ \spad{min(a, b)} to \spad{max(a, b)}.
      ++ The options contained in the list l of the domain
      ++ \spad{DrawOption} are applied.
    sdraw : (PCFUN, SEG) -> VIEW3
      ++ sdraw(f, a..b, l) draws the graph of the parametric
      ++ curve \spad{f} as t ranges from
      ++ \spad{min(a, b)} to \spad{max(a, b)}.

    makeObject : (PSC, SEG, L DROP) -> SPACE3
      ++ makeObject(curve(f, g, h), a..b, l) returns a space of the
      ++ domain \spadtype{ThreeSpace} which contains the graph of the
      ++ parametric curve \spad{x = f(t), y = g(t), z = h(t)} as t ranges from
      ++ \spad{min(a, b)} to \spad{max(a, b)};
      ++ The options contained in the list l of the domain
      ++ \spad{DrawOption} are applied.
    makeObject : (PSC, SEG) -> SPACE3
      ++ makeObject(sp, curve(f, g, h), a..b) returns the space \spad{sp}
      ++ of the domain \spadtype{ThreeSpace} with the addition of the graph
      ++ of the parametric curve \spad{x = f(t), y = g(t), z = h(t)} as t
      ++ ranges from \spad{min(a, b)} to \spad{max(a, b)}.
    makeObject : (PCFUN, SEG, L DROP) -> SPACE3
      ++ makeObject(curve(f, g, h), a..b, l) returns a space of the
      ++ domain \spadtype{ThreeSpace} which contains the graph of the
      ++ parametric curve \spad{x = f(t), y = g(t), z = h(t)} as t ranges from
      ++ \spad{min(a, b)} to \spad{max(a, b)}.
      ++ The options contained in the list l of the domain
      ++ \spad{DrawOption} are applied.
    makeObject : (PCFUN, SEG) -> SPACE3
      ++ makeObject(sp, curve(f, g, h), a..b) returns the space \spad{sp}
      ++ of the domain \spadtype{ThreeSpace} with the addition of the graph
      ++ of the parametric curve \spad{x = f(t), y = g(t), z = h(t)} as t
      ++ ranges from \spad{min(a, b)} to \spad{max(a, b)}.

--% Three Dimensional Function Plots

    sdraw : ((SF, SF) -> SF, SEG, SEG, L DROP) -> VIEW3
      ++ sdraw(f, a..b, c..d, l) draws the graph of \spad{z = f(x, y)}
      ++ as x ranges from \spad{min(a, b)} to \spad{max(a, b)} and y ranges from
      ++ \spad{min(c, d)} to \spad{max(c, d)}.
      ++ and the options contained in the list l of the domain
      ++ \spad{DrawOption} are applied.
    sdraw : ((SF, SF) -> SF, SEG, SEG) -> VIEW3
      ++ sdraw(f, a..b, c..d) draws the graph of \spad{z = f(x, y)}
      ++ as x ranges from \spad{min(a, b)} to \spad{max(a, b)} and y ranges from
      ++ \spad{min(c, d)} to \spad{max(c, d)}.
    makeObject : ((SF, SF) -> SF, SEG, SEG, L DROP) -> SPACE3
      ++ makeObject(f, a..b, c..d, l) returns a space of the domain
      ++ \spadtype{ThreeSpace} which contains the graph of \spad{z = f(x, y)}
      ++ as x ranges from \spad{min(a, b)} to \spad{max(a, b)} and y ranges from
      ++ \spad{min(c, d)} to \spad{max(c, d)}, and the options contained in the
      ++ list l of the domain \spad{DrawOption} are applied.
    makeObject : ((SF, SF) -> SF, SEG, SEG) -> SPACE3
      ++ makeObject(f, a..b, c..d) returns a space of the domain
      ++ \spadtype{ThreeSpace} which contains the graph of \spad{z = f(x, y)}
      ++ as x ranges from \spad{min(a, b)} to \spad{max(a, b)} and y ranges from
      ++ \spad{min(c, d)} to \spad{max(c, d)}.

--% Parametric Surfaces

    sdraw : (PSFUN, SEG, SEG, L DROP) -> VIEW3
      ++ sdraw(f, a..b, c..d) draws the
      ++ graph of the parametric surface \spad{f(u, v)}
      ++ as u ranges from \spad{min(a, b)} to \spad{max(a, b)}
      ++ and v ranges from \spad{min(c, d)} to \spad{max(c, d)}.
      ++ The options contained in the
      ++ list l of the domain \spad{DrawOption} are applied.
    sdraw : (PSFUN, SEG, SEG) -> VIEW3
      ++ sdraw(f, a..b, c..d) draws the
      ++ graph of the parametric surface \spad{f(u, v)}
      ++ as u ranges from \spad{min(a, b)} to \spad{max(a, b)}
      ++ and v ranges from \spad{min(c, d)} to \spad{max(c, d)}
      ++ The options contained in the list
      ++ l of the domain \spad{DrawOption} are applied.
    makeObject : (PSFUN, SEG, SEG, L DROP) -> SPACE3
      ++ makeObject(f, a..b, c..d, l) returns a
      ++ space of the domain \spadtype{ThreeSpace} which contains the
      ++ graph of the parametric surface \spad{f(u, v)}
      ++ as u ranges from \spad{min(a, b)} to
      ++ \spad{max(a, b)} and v ranges from \spad{min(c, d)} to \spad{max(c, d)};
      ++ The options contained in the
      ++ list l of the domain \spad{DrawOption} are applied.
    makeObject : (PSFUN, SEG, SEG) -> SPACE3
      ++ makeObject(f, a..b, c..d, l) returns a
      ++ space of the domain \spadtype{ThreeSpace} which contains the
      ++ graph of the parametric surface \spad{f(u, v)}
      ++ as u ranges from \spad{min(a, b)} to
      ++ \spad{max(a, b)} and v ranges from \spad{min(c, d)} to \spad{max(c, d)}.
    sdraw : (PSF, SEG, SEG, L DROP) -> VIEW3
      ++ sdraw(surface(f, g, h), a..b, c..d) draws the
      ++ graph of the parametric surface \spad{x = f(u, v)}, \spad{y = g(u, v)},
      ++ \spad{z = h(u, v)} as u ranges from \spad{min(a, b)} to \spad{max(a, b)}
      ++ and v ranges from \spad{min(c, d)} to \spad{max(c, d)};
      ++ The options contained in the
      ++ list l of the domain \spad{DrawOption} are applied.
    sdraw : (PSF, SEG, SEG) -> VIEW3
      ++ sdraw(surface(f, g, h), a..b, c..d) draws the
      ++ graph of the parametric surface \spad{x = f(u, v)}, \spad{y = g(u, v)},
      ++ \spad{z = h(u, v)} as u ranges from \spad{min(a, b)} to \spad{max(a, b)}
      ++ and v ranges from \spad{min(c, d)} to \spad{max(c, d)};
    makeObject : (PSF, SEG, SEG, L DROP) -> SPACE3
      ++ makeObject(surface(f, g, h), a..b, c..d, l) returns a
      ++ space of the domain \spadtype{ThreeSpace} which contains the
      ++ graph of the parametric surface \spad{x = f(u, v)}, \spad{y = g(u, v)},
      ++ \spad{z = h(u, v)} as u ranges from \spad{min(a, b)} to
      ++ \spad{max(a, b)} and v ranges from \spad{min(c, d)} to \spad{max(c, d)}.
      ++ The options contained in the
      ++ list l of the domain \spad{DrawOption} are applied.
    makeObject : (PSF, SEG, SEG) -> SPACE3
      ++ makeObject(surface(f, g, h), a..b, c..d, l) returns a
      ++ space of the domain \spadtype{ThreeSpace} which contains the
      ++ graph of the parametric surface \spad{x = f(u, v)}, \spad{y = g(u, v)},
      ++ \spad{z = h(u, v)} as u ranges from \spad{min(a, b)} to
      ++ \spad{max(a, b)} and v ranges from \spad{min(c, d)} to \spad{max(c, d)}.
    recolor : ((SF, SF) -> Pt, (SF, SF, SF) -> SF) -> ((SF, SF) -> Pt)
      ++ recolor(), uninteresting to top level user; exported in order to
      ++ compile package.

  Implementation ==> add
    --!!  I have had to work my way around the following bug in the compiler:
    --!!  When a local variable is given a mapping as a value, e.g.
    --!!  foo : SF -> SF := makeFloatFunction(f, t),
    --!!  the compiler cannot distinguish that local variable from a local
    --!!  function defined elsewhere in the package.  Thus, when 'foo' is
    --!!  passed to a function, e.g.
    --!!  bird := fcn(foo),
    --!!  foo will often be compiled as |DRAW;foo| rather than |foo|. This,
    --!!  of course, causes a run-time error.
    --!!  To avoid this problem, local variables are not given mappings as
    --!!  values, but rather (singleton) lists of mappings.  The first element
    --!!  of the list can always be extracted and everything goes through
    --!!  as before.  There is no major loss in efficiency, as the computation
    --!!  of points will always dominate the computation time.
    --!!                                     - cjw,  22 June MCMXC

    import from PLOT
    import from TwoDimensionalPlotClipping
    import from GraphicsDefaults
    import from ViewportPackage
    import from ThreeDimensionalViewport
    import from DrawOptionFunctions0
    import from MakeFloatCompiledFunction(Ex)
    import from MeshCreationRoutinesForThreeDimensions
    import from SegmentFunctions2(SF, Float)
    import from ViewDefaultsPackage
    import from AnyFunctions1(Pt -> Pt)
    import from AnyFunctions1((SF, SF, SF) -> SF)
    import from DrawOptionFunctions0
    import from SPACE3
    import from SDRAW

    EXTOVARERROR : String := _
      "sdraw: when specifying function, left hand side must be a variable"
    SMALLRANGEERROR : String := _
      "sdraw: range is in interval with only one point"
    DEPVARERROR : String := _
      "sdraw: independent variable appears on lhs of function definition"

------------------------------------------------------------------------
--                     2D - sdraw's
------------------------------------------------------------------------

    drawToScaleRanges : (Segment SF, Segment SF) -> L SEG
    drawToScaleRanges(xVals, yVals) ==
      -- warning: assumes window is square
      xHi := convert(hi xVals)@Float; xLo := convert(lo xVals)@Float
      yHi := convert(hi yVals)@Float; yLo := convert(lo yVals)@Float
      xDiff := xHi - xLo; yDiff := yHi - yLo
      pad := abs(yDiff - xDiff)/2
      yDiff > xDiff =>
        [segment(xLo - pad, xHi + pad), map(x +-> convert(x)@Float, yVals)]
      [map(x +-> convert(x)@Float, xVals), segment(yLo - pad, yHi + pad)]

    make_plot : (PLOT, L DROP) -> GraphImage
    make_plot(plot, l) ==
      branches := listBranches plot
      xRange := xRange plot; yRange := yRange plot
      -- process clipping information
      if (cl := option(l, 'clipSegment)) case "failed" then
        if clipBoolean(l, clipPointsDefault()) then
          clipInfo :=
            parametric? plot => clipParametric plot
            clip plot
          branches := clipInfo.brans
          xRange := clipInfo.xValues; yRange := clipInfo.yValues
        else
          "No explicit user-specified clipping"
      else
        segList := retract(cl :: Any)$ANY1(L SEG)
        empty? segList =>
          error "sdraw: you may specify at least 1 segment for 2D clipping"
        more?(segList, 2) =>
          error "sdraw: you may specify at most 2 segments for 2D clipping"
        xLo : SF := 0; xHi : SF := 0; yLo : SF := 0; yHi : SF := 0
        if empty? rest segList then
          xLo := lo xRange; xHi := hi xRange
          yRangeF := first segList
          yLo := convert(lo yRangeF)@SF; yHi := convert(hi yRangeF)@SF
        else
          xRangeF := first segList
          xLo := convert(lo xRangeF)@SF; xHi := convert(hi xRangeF)@SF
          yRangeF := second segList
          yLo := convert(lo yRangeF)@SF; yHi := convert(hi yRangeF)@SF
        clipInfo := clipWithRanges(branches, xLo, xHi, yLo, yHi)
        branches := clipInfo.brans
        xRange := clipInfo.xValues; yRange := clipInfo.yValues
      -- process scaling information
      if toScale(l, drawToScale()) then
        scaledRanges := drawToScaleRanges(xRange, yRange)
        -- add scaled ranges to list of options
        l := concat(ranges scaledRanges, l)
      else
        xRangeFloat : SEG := map(x +-> convert(x)@Float, xRange)
        yRangeFloat : SEG := map(x +-> convert(x)@Float, yRange)
        -- add ranges to list of options
        l := concat(ranges(ll : L SEG := [xRangeFloat, yRangeFloat]), l)
      -- process color information
      ptCol := pointColorPalette(l, pointColorDefault())
      crCol := curveColorPalette(l, lineColorDefault())
      -- sdraw
      graphCurves(branches, ptCol, crCol, pointSizeDefault(), l)

    normalize : SEG -> Segment SF
    normalize seg ==
      -- normalize [a, b]:
      -- error if a = b, returns [a, b] if a < b, returns [b, a] if b > a
      a := convert(lo seg)@SF; b := convert(hi seg)@SF
      a = b => error SMALLRANGEERROR
      a < b => segment(a, b)
      segment(b, a)

--% functions for creation of maps SF -> Point SF (two dimensional)

    myTrap1 : (SF-> SF, SF) -> SF
    myTrap1(ff : SF-> SF, f : SF) : SF ==
      s := trapNumericErrors(ff(f))$Lisp :: Union(SF, "failed")
      s case "failed" => 0
      r := s::SF
      r >max()$SF => max()$SF
      r < min()$SF => min()$SF
      r

    makePt2 : (SF, SF) -> Point SF
    makePt2(x, y) == point(l : List SF := [x, y])

--% Two Dimensional Function Plots

    makeObject(f : SF -> SF, seg : SEG, l : L DROP) ==
      -- set adaptive plotting off or on
      oldAdaptive := adaptive?()$PLOT
      setAdaptive(adaptive(l, oldAdaptive))$PLOT
      -- create function SF -> Point SF
      ff : L(SF -> Point SF) := [x +-> makePt2(myTrap1(f, x), x)]
      -- process change of coordinates
      if (c := option(l, 'coordinates)) case "failed" then
        -- default coordinate transformation
        ff := [x +-> makePt2(x, myTrap1(f, x))]
      else
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        ff := [x +-> (first cc)((first ff)(x))]
      -- create PLOT
      pl := pointPlot(first ff, normalize seg)
      -- reset adaptive plotting
      setAdaptive(oldAdaptive)$PLOT
      -- sdraw
      make_plot(pl, l)

    sdraw(f : SF -> SF, seg : SEG, l : L DROP) ==
        g:= makeObject(f, seg, l)
        writeViewport2D(g,l)$SDRAW

    sdraw(f : SF -> SF, seg : SEG) == sdraw(f, seg, nil())

--% Parametric Plane Curves

    makeObject(ppc : PPC, seg : SEG, l : L DROP) ==
      -- set adaptive plotting off or on
      oldAdaptive := adaptive?()$PLOT
      setAdaptive(adaptive(l, oldAdaptive))$PLOT
      -- create function SF -> Point SF
      f := coordinate(ppc, 1); g := coordinate(ppc, 2)
      fcn : L(SF -> Pt) := [x +-> makePt2(myTrap1(f, x), myTrap1(g, x))]
      -- process change of coordinates
      if not (c := option(l, 'coordinates)) case "failed" then
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        fcn := [x +-> (first cc)((first fcn)(x))]
      -- create PLOT
      pl := pointPlot(first fcn, normalize seg)
      -- reset adaptive plotting
      setAdaptive(oldAdaptive)$PLOT
      -- sdraw
      make_plot(pl, l)

    sdraw(ppc : PPC, seg : SEG, l : L DROP) ==
        g := makeObject(ppc, seg, l)
        writeViewport2D(g, l)

    sdraw(ppc : PPC, seg : SEG) == sdraw(ppc, seg, nil())

------------------------------------------------------------------------
--                     3D - Curves
------------------------------------------------------------------------

--% functions for creation of maps SF -> Point SF (three dimensional)

    makePt4 : (SF, SF, SF, SF) -> Point SF
    makePt4(x, y, z, c) == point(l : List SF := [x, y, z, c])

--% Parametric Space Curves

    id : SF -> SF
    id x == x

    zCoord : (SF, SF, SF) -> SF
    zCoord(x, y, z) == z

    colorPoints : (List List Pt, (SF, SF, SF) -> SF) -> List List Pt
    colorPoints(llp, func) ==
      for lp in llp repeat for p in lp repeat
        p.4 := func(p.1, p.2, p.3)
      llp

    makeObject(psc : PSC, seg : SEG, l : L DROP) ==
      sp := space l
      -- obtain dependent variable and coordinate functions
      f := coordinate(psc, 1); g := coordinate(psc, 2); h := coordinate(psc, 3)
      -- create function SF -> Point SF with default or user-specified
      -- color function
      fcn : L(SF -> Pt) := [x +-> makePt4(myTrap1(f, x), myTrap1(g, x), _
                            myTrap1(h, x), myTrap1(id, x))]
      pointsColored? : Boolean := false
      if not (c1 := option(l, 'colorFunction1)) case "failed" then
        pointsColored? := true
        fcn := [x +-> makePt4(myTrap1(f, x), myTrap1(g, x), _
                myTrap1(h, x), retract(c1 :: Any)$ANY1(SF -> SF)(x))]
      -- process change of coordinates
      if not (c := option(l, 'coordinates)) case "failed" then
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        fcn := [x +-> (first cc)((first fcn)(x))]
      -- create PLOT
      pl := pointPlot(first fcn, normalize seg)$Plot3D
      -- create ThreeSpace
      s := sp
      -- sdraw Tube
--      print(pl::OutputForm)
      option?(l, 'tubeRadius) =>
        pts := tubePoints(l, 8)
        rad := convert(tubeRadius(l, 0.25))@DoubleFloat
        tub := tube(pl, rad, pts)$NumericTubePlot(Plot3D)
        loops := listLoops tub
        -- color points if this has not been done already
        if not pointsColored? then
          if (c3 := option(l, 'colorFunction3)) case "failed"
            then colorPoints(loops, zCoord)  -- default color function
            else colorPoints(loops, retract(c3 :: Any)$ANY1((SF, SF, SF) -> SF))
        mesh(s, loops, false, false)
        s
      -- sdraw curve
      br := listBranches pl
      for b in br repeat curve(s, b)
      s

    makeObject(psc : PCFUN, seg : SEG, l : L DROP) ==
      sp := space l
      -- create function SF -> Point SF with default or user-specified
      -- color function
      fcn : L(SF -> Pt) := [psc]
      pointsColored? : Boolean := false
      if not (c1 := option(l, 'colorFunction1)) case "failed" then
        pointsColored? := true
        fcn := [x +-> concat(psc(x), retract(c1 :: Any)$ANY1(SF -> SF)(x))]
      -- process change of coordinates
      if not (c := option(l, 'coordinates)) case "failed" then
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        fcn := [x +-> (first cc)((first fcn)(x))]
      -- create PLOT
      pl := pointPlot(first fcn, normalize seg)$Plot3D
      -- create ThreeSpace
      s := sp
      -- sdraw Tube
      option?(l, 'tubeRadius) =>
        pts := tubePoints(l, 8)
        rad := convert(tubeRadius(l, 0.25))@DoubleFloat
        tub := tube(pl, rad, pts)$NumericTubePlot(Plot3D)
        loops := listLoops tub
        -- color points if this has not been done already
        mesh(s, loops, false, false)
        s
      -- sdraw curve
      br := listBranches pl
      for b in br repeat curve(s, b)
      s

    makeObject(psc : PSC, seg : SEG) ==
      makeObject(psc, seg, nil())

    makeObject(psc : PCFUN, seg : SEG) ==
      makeObject(psc, seg, nil())

    sdraw(psc : PSC, seg : SEG, l : L DROP) ==
      sp := makeObject(psc, seg, l)
      writeViewport3D(sp, l)

    sdraw(psc : PSC, seg : SEG) ==
      sdraw(psc, seg, nil())

    sdraw(psc : PCFUN, seg : SEG, l : L DROP) ==
      sp := makeObject(psc, seg, l)
      writeViewport3D(sp, l)

    sdraw(psc : PCFUN, seg : SEG) ==
      sdraw(psc, seg, nil())

------------------------------------------------------------------------
--                     3D - Surfaces
------------------------------------------------------------------------

    myTrap2 : ((SF, SF) -> SF, SF, SF) -> SF
    myTrap2(ff : (SF, SF) -> SF, u : SF, v : SF) : SF ==
      s := trapNumericErrors(ff(u, v))$Lisp :: Union(SF, "failed")
      s case "failed" =>  0
      r : SF := s::SF
      r >max()$SF => max()$SF
      r < min()$SF => min()$SF
      r

    recolor(ptFunc, colFunc) ==
      (f1, f2) +->
        pt := ptFunc(f1, f2)
        pt.4 := colFunc(pt.1, pt.2, pt.3)
        pt

    xCoord : (SF, SF) -> SF
    xCoord(x, y) == x

--% Three Dimensional Function Plots

    makeObject(f : (SF, SF) -> SF, xSeg : SEG, ySeg : SEG, l : L DROP) ==
      sp := space l
      -- process color function of two variables
      col2 : L((SF, SF) -> SF) := [xCoord]     -- dummy color function
      pointsColored? : Boolean := false
      if not (c2 := option(l, 'colorFunction2)) case "failed" then
        pointsColored? := true
        col2 := [retract(c2 :: Any)$ANY1((SF, SF) -> SF)]
      fcn : L((SF, SF) -> Pt) :=
        [(x, y) +-> makePt4(myTrap2(f, x, y), x, y, (first col2)(x, y))]
      -- process change of coordinates
      if (c := option(l, 'coordinates)) case "failed" then
        -- default coordinate transformation
        fcn := [(x, y) +-> makePt4(x, y, myTrap2(f, x, y), (first col2)(x, y))]
      else
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        fcn := [(x, y) +-> (first cc)((first fcn)(x, y))]
      -- process color function of three variables, if there was no
      -- color function of two variables
      if not pointsColored? then
        c := option(l, 'colorFunction3)
        fcn :=
          c case "failed" => [recolor((first fcn),zCoord)]
          [recolor((first fcn), retract(c :: Any)$ANY1((SF, SF, SF) -> SF))]
      -- create mesh
      mesh := meshPar2Var(sp, first fcn, normalize xSeg, normalize ySeg, l)
      mesh

    makeObject(f : (SF, SF) -> SF, xSeg : SEG, ySeg : SEG) ==
      makeObject(f, xSeg, ySeg, nil())

    sdraw(f : (SF, SF) -> SF, xSeg : SEG, ySeg : SEG, l : L DROP) ==
      sp := makeObject(f, xSeg, ySeg, l)
      writeViewport3D(sp, l)

    sdraw(f : (SF, SF) -> SF, xSeg : SEG, ySeg : SEG) ==
      sdraw(f, xSeg, ySeg, nil())

--% parametric surface

    makeObject(s : PSF, uSeg : SEG, vSeg : SEG, l : L DROP) ==
      sp := space l
      -- create functions from expressions
      f : L((SF, SF) -> SF) := [coordinate(s, 1)]
      g : L((SF, SF) -> SF) := [coordinate(s, 2)]
      h : L((SF, SF) -> SF) := [coordinate(s, 3)]
      -- process color function of two variables
      col2 : L((SF, SF) -> SF) := [xCoord]     -- dummy color function
      pointsColored? : Boolean := false
      if not (c2 := option(l, 'colorFunction2)) case "failed" then
        pointsColored? := true
        col2 := [retract(c2 :: Any)$ANY1((SF, SF) -> SF)]
      fcn : L((SF, SF) -> Pt) :=
        [(x, y) +-> makePt4(myTrap2((first f), x, y), myTrap2((first g), x, y),
         myTrap2((first h), x, y), myTrap2((first col2), x, y))]
      -- process change of coordinates
      if not (c := option(l, 'coordinates)) case "failed" then
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        fcn := [(x, y) +-> (first cc)((first fcn)(x, y))]
      -- process color function of three variables, if there was no
      -- color function of two variables
      if not pointsColored? then
        col3 : L((SF, SF, SF) -> SF) := [zCoord]  -- default color function
        if not (c := option(l, 'colorFunction3)) case "failed" then
          col3 := [retract(c :: Any)$ANY1((SF, SF, SF) -> SF)]
        fcn := [recolor((first fcn), (first col3))]
      -- create mesh
      mesh := meshPar2Var(sp, first fcn, normalize uSeg, normalize vSeg, l)
      mesh

    makeObject(s : PSFUN, uSeg : SEG, vSeg : SEG, l : L DROP) ==
      sp := space l
      -- process color function of two variables
      col2 : L((SF, SF) -> SF) := [xCoord]     -- dummy color function
      pointsColored? : Boolean := false
      if not (c2 := option(l, 'colorFunction2)) case "failed" then
        pointsColored? := true
        col2 := [retract(c2 :: Any)$ANY1((SF, SF) -> SF)]
      fcn : L((SF, SF) -> Pt) :=
        pointsColored? => [(x, y) +-> concat(s(x, y), (first col2)(x, y))]
        [s]
      -- process change of coordinates
      if not (c := option(l, 'coordinates)) case "failed" then
        cc : L(Pt -> Pt) := [retract(c :: Any)$ANY1(Pt -> Pt)]
        fcn := [(x, y) +-> (first cc)((first fcn)(x, y))]
      -- create mesh
      mesh := meshPar2Var(sp, first fcn, normalize uSeg, normalize vSeg, l)
      mesh

    makeObject(s : PSF, uSeg : SEG, vSeg : SEG) ==
      makeObject(s, uSeg, vSeg, nil())

    sdraw(s : PSF, uSeg : SEG, vSeg : SEG, l : L DROP) ==
      -- sdraw
      mesh := makeObject(s, uSeg, vSeg, l)
      writeViewport3D(mesh, l)

    sdraw(s : PSF, uSeg : SEG, vSeg : SEG) ==
      sdraw(s, uSeg, vSeg, nil())

    makeObject(s : PSFUN, uSeg : SEG, vSeg : SEG) ==
      makeObject(s, uSeg, vSeg, nil())

    sdraw(s : PSFUN, uSeg : SEG, vSeg : SEG, l : L DROP) ==
      -- sdraw
      mesh := makeObject(s, uSeg, vSeg, l)
      writeViewport3D(mesh, l)

    sdraw(s : PSFUN, uSeg : SEG, vSeg : SEG) ==
      sdraw(s, uSeg, vSeg, nil())

)abbrev package DRAW0 STopLevelDrawFunctions
++ Author: Clifton J. Williamson
++ Date Created: 23 January 1990
++ Basic Operations: sdraw
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: TopLevelDrawFunctions provides top level functions for
++ drawing graphics of expressions.
STopLevelDrawFunctions(Ex : Join(ConvertibleTo InputForm, SetCategory)):
 Exports == Implementation where
  B    ==> Boolean
  BIND ==> SegmentBinding Float
  L    ==> List
  SF   ==> DoubleFloat
  DROP ==> DrawOption

  PPC  ==> ParametricPlaneCurve Ex
  PPCF ==> ParametricPlaneCurve(SF -> SF)
  PSC  ==> ParametricSpaceCurve Ex
  PSCF ==> ParametricSpaceCurve(SF -> SF)
  PSF  ==> ParametricSurface Ex
  PSFF ==> ParametricSurface((SF, SF) -> SF)
  SPACE3 ==> ThreeSpace(SF)
  VIEW2 ==> String
  VIEW3 ==> String
  SDRAW ==> SaveDraw

  Exports ==> with

--% Two Dimensional Function Plots

    sdraw : (Ex, BIND, L DROP) -> VIEW2
      ++ sdraw(f(x), x = a..b, l) draws the graph of \spad{y = f(x)} as x
      ++ ranges from \spad{min(a, b)} to \spad{max(a, b)}; \spad{f(x)} is the
      ++ default title, and the options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    sdraw : (Ex, BIND) -> VIEW2
      ++ sdraw(f(x), x = a..b) draws the graph of \spad{y = f(x)} as x
      ++ ranges from \spad{min(a, b)} to \spad{max(a, b)}; \spad{f(x)} appears
      ++ in the title bar.
    makeObject : (Ex, BIND, L DROP) -> GraphImage
      ++ makeObjectf(x), x = a..b, l) creates the graph of \spad{y = f(x)} as x
      ++ ranges from \spad{min(a, b)} to \spad{max(a, b)}; the options
      ++ contained in the list l of the domain \spad{DrawOption} are applied.

--% Parametric Plane Curves

    sdraw : (PPC, BIND, L DROP) -> VIEW2
      ++ sdraw(curve(f(t), g(t)), t = a..b, l) draws the graph of the parametric
      ++ curve \spad{x = f(t), y = g(t)} as t ranges from \spad{min(a, b)} to
      ++ \spad{max(a, b)}; \spad{(f(t), g(t))} is the default title, and the
      ++ options contained in the list l of the domain \spad{DrawOption}
      ++ are applied.
    sdraw : (PPC, BIND) -> VIEW2
      ++ sdraw(curve(f(t), g(t)), t = a..b) draws the graph of the parametric
      ++ curve \spad{x = f(t), y = g(t)} as t ranges from \spad{min(a, b)} to
      ++ \spad{max(a, b)}; \spad{(f(t), g(t))} appears in the title bar.
    makeObject : (PPC, BIND, L DROP) -> GraphImage
      ++ makeObject(curve(f(t), g(t)), t = a..b, l) creates the graph of
      ++ the parametric curve \spad{x = f(t), y = g(t)} as t ranges
      ++ from \spad{min(a, b)} to \spad{max(a, b)}; the options
      ++ contained in the list l of the domain \spad{DrawOption}
      ++ are applied.

--% Parametric Space Curves

    sdraw : (PSC, BIND, L DROP) -> VIEW3
      ++ sdraw(curve(f(t), g(t), h(t)), t = a..b, l) draws the graph of the
      ++ parametric curve \spad{x = f(t)}, \spad{y = g(t)}, \spad{z = h(t)}
      ++ as t ranges from \spad{min(a, b)} to \spad{max(a, b)}; \spad{h(t)}
      ++ is the default title, and the options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    sdraw : (PSC, BIND) -> VIEW3
      ++ sdraw(curve(f(t), g(t), h(t)), t = a..b) draws the graph of the parametric
      ++ curve \spad{x = f(t)}, \spad{y = g(t)}, \spad{z = h(t)} as t ranges
      ++ from \spad{min(a, b)} to \spad{max(a, b)}; \spad{h(t)} is the default
      ++ title.
    makeObject : (PSC, BIND, L DROP) -> SPACE3
      ++ makeObject(curve(f(t), g(t), h(t)), t = a..b, l) returns a space of
      ++ the domain \spadtype{ThreeSpace} which contains the graph of the
      ++ parametric curve \spad{x = f(t)}, \spad{y = g(t)}, \spad{z = h(t)}
      ++ as t ranges from \spad{min(a, b)} to \spad{max(a, b)}; \spad{h(t)}
      ++ is the default title, and the options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    makeObject : (PSC, BIND) -> SPACE3
      ++ makeObject(curve(f(t), g(t), h(t)), t = a..b) returns a space of the
      ++ domain \spadtype{ThreeSpace} which contains the graph of the
      ++ parametric curve \spad{x = f(t)}, \spad{y = g(t)}, \spad{z = h(t)}
      ++ as t ranges from \spad{min(a, b)} to \spad{max(a, b)}; \spad{h(t)} is
      ++ the default title.

--% Three Dimensional Function Plots

    sdraw : (Ex, BIND, BIND, L DROP) -> VIEW3
      ++ sdraw(f(x, y), x = a..b, y = c..d, l) draws the graph of \spad{z = f(x, y)}
      ++ as x ranges from \spad{min(a, b)} to \spad{max(a, b)} and y ranges from
      ++ \spad{min(c, d)} to \spad{max(c, d)}; \spad{f(x, y)} is the default
      ++ title, and the options contained in the list l of the domain
      ++ \spad{DrawOption} are applied.
    sdraw : (Ex, BIND, BIND) -> VIEW3
      ++ sdraw(f(x, y), x = a..b, y = c..d) draws the graph of \spad{z = f(x, y)}
      ++ as x ranges from \spad{min(a, b)} to \spad{max(a, b)} and y ranges from
      ++ \spad{min(c, d)} to \spad{max(c, d)}; \spad{f(x, y)} appears in the title bar.
    makeObject : (Ex, BIND, BIND, L DROP) -> SPACE3
      ++ makeObject(f(x, y), x = a..b, y = c..d, l) returns a space of the
      ++ domain \spadtype{ThreeSpace} which contains the graph of
      ++ \spad{z = f(x, y)} as x ranges from \spad{min(a, b)} to \spad{max(a, b)}
      ++ and y ranges from \spad{min(c, d)} to \spad{max(c, d)}; \spad{f(x, y)}
      ++ is the default title, and the options contained in the list l of the
      ++ domain \spad{DrawOption} are applied.
    makeObject : (Ex, BIND, BIND) -> SPACE3
      ++ makeObject(f(x, y), x = a..b, y = c..d) returns a space of the domain
      ++ \spadtype{ThreeSpace} which contains the graph of \spad{z = f(x, y)}
      ++ as x ranges from \spad{min(a, b)} to \spad{max(a, b)} and y ranges from
      ++ \spad{min(c, d)} to \spad{max(c, d)}; \spad{f(x, y)} appears as the
      ++ default title.

--% Parametric Surfaces

    sdraw : (PSF, BIND, BIND, L DROP) -> VIEW3
      ++ sdraw(surface(f(u, v), g(u, v), h(u, v)), u = a..b, v = c..d, l) draws the
      ++ graph of the parametric surface \spad{x = f(u, v)}, \spad{y = g(u, v)},
      ++ \spad{z = h(u, v)} as u ranges from \spad{min(a, b)} to \spad{max(a, b)}
      ++ and v ranges from \spad{min(c, d)} to \spad{max(c, d)}; \spad{h(t)}
      ++ is the default title, and the options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    sdraw : (PSF, BIND, BIND) -> VIEW3
      ++ sdraw(surface(f(u, v), g(u, v), h(u, v)), u = a..b, v = c..d) draws the
      ++ graph of the parametric surface \spad{x = f(u, v)}, \spad{y = g(u, v)},
      ++ \spad{z = h(u, v)} as u ranges from \spad{min(a, b)} to \spad{max(a, b)}
      ++ and v ranges from \spad{min(c, d)} to \spad{max(c, d)}; \spad{h(t)} is
      ++ the default title.
    makeObject : (PSF, BIND, BIND, L DROP) -> SPACE3
      ++ makeObject(surface(f(u, v), g(u, v), h(u, v)), u = a..b, v = c..d, l) returns
      ++ a space of the domain \spadtype{ThreeSpace} which contains the graph
      ++ of the parametric surface \spad{x = f(u, v)}, \spad{y = g(u, v)},
      ++ \spad{z = h(u, v)} as u ranges from \spad{min(a, b)} to \spad{max(a, b)}
      ++ and v ranges from \spad{min(c, d)} to \spad{max(c, d)}; \spad{h(t)} is
      ++ the default title, and the options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    makeObject : (PSF, BIND, BIND) -> SPACE3
      ++ makeObject(surface(f(u, v), g(u, v), h(u, v)), u = a..b, v = c..d) returns
      ++ a space of the domain \spadtype{ThreeSpace} which contains the
      ++ graph of the parametric surface \spad{x = f(u, v)}, \spad{y = g(u, v)},
      ++ \spad{z = h(u, v)} as u ranges from \spad{min(a, b)} to \spad{max(a, b)}
      ++ and v ranges from \spad{min(c, d)} to \spad{max(c, d)}; \spad{h(t)} is
      ++ the default title.

  Implementation ==> add
    import from STopLevelDrawFunctionsForCompiledFunctions
    import from MakeFloatCompiledFunction(Ex)
    import from ParametricPlaneCurve(SF -> SF)
    import from ParametricSpaceCurve(SF -> SF)
    import from ParametricSurface((SF, SF) -> SF)
    import from ThreeSpace(SF)
    import from SDRAW


------------------------------------------------------------------------
--                     2D - sdraw's  (given by formulae)
------------------------------------------------------------------------

--% Two Dimensional Function Plots

    makeObject(f : Ex, bind : BIND, l : L DROP) ==
        -- use SDCFUN
        makeObject(makeFloatFunction(f, variable bind), segment bind, l)

    sdraw(f : Ex, bind : BIND, l : L DROP) ==
        -- create title if necessary
        if not option?(l, 'title) then
            s : String := unparse(convert(f)@InputForm)
            if sayLength(s)$DisplayPackage > 50 then
                l := concat(title "FriCAS2D", l)
            else l := concat(title s, l)
        g := makeObject(f, bind, l)
        writeViewport2D(g, l)

    sdraw(f : Ex, bind : BIND) == sdraw(f, bind, nil())

--% Parametric Plane Curves

    makeObject(ppc : PPC, bind : BIND, l : L DROP) ==
        f := coordinate(ppc, 1); g := coordinate(ppc, 2)
        -- create curve with functions as coordinates
        curve : PPCF := curve(makeFloatFunction(f, variable bind), _
                            makeFloatFunction(g, variable bind))$PPCF
        -- use SDCFUN
        makeObject(curve, segment bind, l)

    sdraw(ppc : PPC, bind : BIND, l : L DROP) ==
        f := coordinate(ppc, 1)
        -- create title if necessary
        if not option?(l, 'title) then
            s : String := unparse(convert(f)@InputForm)
            if sayLength(s)$DisplayPackage > 50 then
                l := concat(title "FriCAS2D", l)
            else l := concat(title s, l)
        g := makeObject(ppc, bind, l)
        writeViewport2D(g, l)

    sdraw(ppc : PPC, bind : BIND) == sdraw(ppc, bind, nil())

------------------------------------------------------------------------
--                     3D - Curves  (given by formulas)
------------------------------------------------------------------------

    makeObject(psc : PSC, tBind : BIND, l : L DROP) ==
      -- obtain dependent variable and coordinate functions
      t := variable tBind; tSeg := segment tBind
      f := coordinate(psc, 1); g := coordinate(psc, 2); h := coordinate(psc, 3)
      -- create title if necessary
      if not option?(l, 'title) then
        s : String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "FriCAS3D",l)
        else l := concat(title s, l)
      -- indicate sdraw style if necessary
      if not option?(l, 'style) then
        l := concat(style unparse(convert(f)@InputForm), l)
      -- create curve with functions as coordinates
      curve : PSCF := curve(makeFloatFunction(f, t), _
                            makeFloatFunction(g, t), _
                            makeFloatFunction(h, t))
      -- call 'sdraw'
      makeObject(curve, tSeg, l)

    makeObject(psc : PSC, tBind : BIND) ==
      makeObject(psc, tBind, nil())

    sdraw(psc : PSC, tBind : BIND, l : L DROP) ==
      -- obtain dependent variable and coordinate functions
      t := variable tBind; tSeg := segment tBind
      f := coordinate(psc, 1); g := coordinate(psc, 2); h := coordinate(psc, 3)
      -- create title if necessary
      if not option?(l, 'title) then
        s : String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "FriCAS3D",l)
        else l := concat(title s, l)
      -- indicate sdraw style if necessary
      if not option?(l, 'style) then
        l := concat(style unparse(convert(f)@InputForm), l)
      -- create curve with functions as coordinates
      curve : PSCF := curve(makeFloatFunction(f, t), _
                            makeFloatFunction(g, t), _
                            makeFloatFunction(h, t))
      -- call 'sdraw'
      sdraw(curve, tSeg, l)

    sdraw(psc : PSC, tBind : BIND) ==
      sdraw(psc, tBind, nil())

------------------------------------------------------------------------
--                     3D - Surfaces  (given by formulas)
------------------------------------------------------------------------

--% Three Dimensional Function Plots

    makeObject(f : Ex, xBind : BIND, yBind : BIND, l : L DROP) ==
      -- create title if necessary
      if not option?(l, 'title) then
        s : String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "FriCAS3D",l)
        else l := concat(title s, l)
      -- indicate sdraw style if necessary
      if not option?(l, 'style) then
        l := concat(style unparse(convert(f)@InputForm), l)
      -- obtain dependent variables and their ranges
      x := variable xBind; xSeg := segment xBind
      y := variable yBind; ySeg := segment yBind
      -- call 'sdraw'
      makeObject(makeFloatFunction(f, x, y), xSeg, ySeg, l)

    makeObject(f : Ex, xBind : BIND, yBind : BIND) ==
      makeObject(f, xBind, yBind, nil())

    sdraw(f : Ex, xBind : BIND, yBind : BIND, l : L DROP) ==
      -- create title if necessary
      if not option?(l, 'title) then
        s : String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "FriCAS3D",l)
        else l := concat(title s, l)
      -- indicate sdraw style if necessary
      if not option?(l, 'style) then
        l := concat(style unparse(convert(f)@InputForm), l)
      -- obtain dependent variables and their ranges
      x := variable xBind; xSeg := segment xBind
      y := variable yBind; ySeg := segment yBind
      -- call 'sdraw'
      sdraw(makeFloatFunction(f, x, y), xSeg, ySeg, l)

    sdraw(f : Ex, xBind : BIND, yBind : BIND) ==
      sdraw(f, xBind, yBind, nil())

--% parametric surface

    makeObject(s : PSF, uBind : BIND, vBind : BIND, l : L DROP) ==
      f := coordinate(s, 1); g := coordinate(s, 2); h := coordinate(s, 3)
      if not option?(l, 'title) then
        s : String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "FriCAS3D",l)
        else l := concat(title s, l)
      if not option?(l, 'style) then
        l := concat(style unparse(convert(f)@InputForm), l)
      u := variable uBind; uSeg := segment uBind
      v := variable vBind; vSeg := segment vBind
      surf : PSFF := surface(makeFloatFunction(f, u, v), _
                             makeFloatFunction(g, u, v), _
                             makeFloatFunction(h, u, v))
      makeObject(surf, uSeg, vSeg, l)

    makeObject(s : PSF, uBind : BIND, vBind : BIND) ==
      makeObject(s, uBind, vBind, nil())

    sdraw(s : PSF, uBind : BIND, vBind : BIND, l : L DROP) ==
      f := coordinate(s, 1); g := coordinate(s, 2); h := coordinate(s, 3)
      -- create title if necessary
      if not option?(l, 'title) then
        s : String := unparse(convert(f)@InputForm)
        if sayLength(s)$DisplayPackage > 50 then
          l := concat(title "FriCAS3D",l)
        else l := concat(title s, l)
      -- indicate sdraw style if necessary
      if not option?(l, 'style) then
        l := concat(style unparse(convert(f)@InputForm), l)
      -- obtain dependent variables and their ranges
      u := variable uBind; uSeg := segment uBind
      v := variable vBind; vSeg := segment vBind
      -- create surface with functions as coordinates
      surf : PSFF := surface(makeFloatFunction(f, u, v), _
                             makeFloatFunction(g, u, v), _
                             makeFloatFunction(h, u, v))
      -- call 'sdraw'
      sdraw(surf, uSeg, vSeg, l)

    sdraw(s : PSF, uBind : BIND, vBind : BIND) ==
      sdraw(s, uBind, vBind, nil())

)abbrev package SDRAWCUR STopLevelDrawFunctionsForAlgebraicCurves
++ Author: Clifton J. Williamson
++ Date Created: 26 June 1990
++ Basic Operations: sdraw
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: TopLevelDrawFunctionsForAlgebraicCurves provides top level
++ functions for drawing non-singular algebraic curves.

STopLevelDrawFunctionsForAlgebraicCurves(R, Ex) : Exports == Implementation where
  R  : Join(IntegralDomain, Comparable, RetractableTo Integer)
  Ex : FunctionSpace(R)

  ANY1  ==> AnyFunctions1
  DROP  ==> DrawOption
  EQ    ==> Equation
  F     ==> Float
  FRAC  ==> Fraction
  I     ==> Integer
  L     ==> List
  P     ==> Polynomial
  RN    ==> Fraction Integer
  SEG   ==> Segment
  SY    ==> Symbol
  VIEW2 ==> String
  SDRAW ==> SaveDraw

  Exports ==> with

    sdraw : (EQ Ex, SY, SY, L DROP) -> VIEW2
      ++ sdraw(f(x, y) = g(x, y), x, y, l) draws the graph of a polynomial
      ++ equation.  The list l of sdraw options must specify a region
      ++ in the plane in which the curve is to sketched.
    makeObject : (EQ Ex, SY, SY, L DROP) -> GraphImage
      ++ makeObject(f(x, y) = g(x, y), x, y, l) creates the graph of
      ++ a polynomial equation. The list l of sdraw options must specify
      ++ a region in the plane in which the curve is to sketched.

  Implementation ==> add
    import from ViewportPackage
    import from PlaneAlgebraicCurvePlot
    import from ViewDefaultsPackage
    import from GraphicsDefaults
    import from DrawOptionFunctions0
    import from SegmentFunctions2(RN, F)
    import from SegmentFunctions2(F, RN)
    import from AnyFunctions1(L SEG RN)
    import from SDRAW


    drawToScaleRanges : (SEG F, SEG F) -> L SEG F
    drawToScaleRanges(xVals, yVals) ==
      -- warning: assumes window is square
      xHi := hi xVals; xLo := lo xVals
      yHi := hi yVals; yLo := lo yVals
      xDiff := xHi - xLo; yDiff := yHi - yLo
      pad := abs(yDiff - xDiff)/2
      yDiff > xDiff =>
        [segment(xLo - pad, xHi + pad), yVals]
      [xVals, segment(yLo - pad, yHi + pad)]

    intConvert : R -> I
    intConvert r ==
      (nn := retractIfCan(r)@Union(I,"failed")) case "failed" =>
        error "sdraw: polynomial must have rational coefficients"
      nn :: I

    polyEquation : EQ Ex -> P I
    polyEquation eq ==
      ff := lhs(eq) - rhs(eq)
      (r := retractIfCan(ff)@Union(FRAC P R,"failed")) case "failed" =>
        error "sdraw: not a polynomial equation"
      rat := r :: FRAC P R
      retractIfCan(denom rat)@Union(R,"failed") case "failed" =>
        error "sdraw: non-constant denominator"
      map(intConvert, numer rat)$PolynomialFunctions2(R, I)

    makeObject(eq, x, y, l) ==
      -- obtain polynomial equation
      p := polyEquation eq
      -- extract ranges from option list
      floatRange := option(l, 'rangeFloat)
      ratRange := option(l, 'rangeRat)
      (floatRange case "failed") and (ratRange case "failed") =>
        error "sdraw: you must specify ranges for an implicit plot"
      ranges : L SEG RN := nil()             -- dummy value
      floatRanges : L SEG F := nil()         -- dummy value
      xRange : SEG RN := segment(0, 0)        -- dummy value
      yRange : SEG RN := segment(0, 0)        -- dummy value
      xRangeFloat : SEG F := segment(0, 0)    -- dummy value
      yRangeFloat : SEG F := segment(0, 0)    -- dummy value
      if not ratRange case "failed" then
        ranges := retract(ratRange :: Any)$ANY1(L SEG RN)
        not size?(ranges,2) => error "sdraw: you must specify two ranges"
        xRange := first ranges; yRange := second ranges
        xRangeFloat := map((s : RN) : F +-> convert(s)@Float, xRange)@(SEG F)
        yRangeFloat := map((s : RN) : F +-> convert(s)@Float, yRange)@(SEG F)
        floatRanges := [xRangeFloat, yRangeFloat]
      else
        floatRanges := retract(floatRange :: Any)$ANY1(L SEG F)
        not size?(floatRanges, 2) =>
          error "sdraw: you must specify two ranges"
        xRangeFloat := first floatRanges
        yRangeFloat := second floatRanges
        xRange := map((s : F) : RN +-> retract(s)@RN, xRangeFloat)@(SEG RN)
        yRange := map((s : F) : RN +-> retract(s)@RN, yRangeFloat)@(SEG RN)
        ranges := [xRange, yRange]
      -- create curve plot
      acplot := makeSketch(p, x, y, xRange, yRange)
      -- process scaling information
      if toScale(l, drawToScale()) then
        scaledRanges := drawToScaleRanges(xRangeFloat, yRangeFloat)
        -- add scaled ranges to list of options
        l := concat(ranges scaledRanges, l)
      else
        -- add ranges to list of options
        l := concat(ranges floatRanges, l)
      -- process color information
      ptCol := pointColorPalette(l, pointColorDefault())
      crCol := curveColorPalette(l, lineColorDefault())
      -- sdraw
      graphCurves(listBranches acplot, ptCol, crCol, pointSizeDefault(), l)

    sdraw(eq, x, y, l) ==
        g := makeObject(eq, x, y, l)
        writeViewport2D(g, l)

)abbrev package SDRAWPT STopLevelDrawFunctionsForPoints
++ Author: Mike Dewar
++ Date Created: 24 May 1995
++ Basic Operations: sdraw
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ Description: TopLevelDrawFunctionsForPoints provides top level functions for
++ drawing curves and surfaces described by sets of points.

STopLevelDrawFunctionsForPoints() : Exports == Implementation where

  DROP  ==> DrawOption
  L     ==> List
  SF    ==> DoubleFloat
  Pt    ==> Point SF
  VIEW2 ==> String
  VIEW3 ==> String
  SDRAW ==> SaveDraw

  Exports ==> with
    sdraw : (L SF, L SF) -> VIEW2
      ++ sdraw(lx, ly) plots the curve constructed of points (x, y) for x
      ++ in \spad{lx} for y in \spad{ly}.
    sdraw : (L SF, L SF, L DROP) -> VIEW2
      ++ sdraw(lx, ly, l) plots the curve constructed of points (x, y) for x
      ++ in \spad{lx} for y in \spad{ly}.
      ++ The options contained in the list l of
      ++ the domain \spad{DrawOption} are applied.
    sdraw : (L Pt) -> VIEW2
      ++ sdraw(lp) plots the curve constructed from the list of points lp.
    sdraw : (L Pt, L DROP) -> VIEW2
      ++ sdraw(lp, l) plots the curve constructed from the list of points lp.
      ++ The options contained in the list l of the domain \spad{DrawOption}
      ++ are applied.
    sdraw : (L SF, L SF, L SF) -> VIEW3
      ++ sdraw(lx, ly, lz) draws the surface constructed by projecting the values
      ++ in the \spad{lz} list onto the rectangular grid formed by the
      ++ \spad{lx X ly}.
    sdraw : (L SF, L SF, L SF, L DROP) -> VIEW3
      ++ sdraw(lx, ly, lz, l) draws the surface constructed by projecting the values
      ++ in the \spad{lz} list onto the rectangular grid formed by the
      ++ The options contained in the list l of the domain \spad{DrawOption}
      ++ are applied.

  Implementation ==> add
  
    import from SDRAW

    sdraw(lp : L Pt, l : L DROP) : VIEW2 ==
      writeViewport2D(makeGraphImage([lp])$GraphImage, l)

    sdraw(lp : L Pt) : VIEW2 == sdraw(lp, [])

    sdraw(lx : L SF, ly : L SF, l : L DROP) : VIEW2 ==
      sdraw([point([x, y])$Pt for x in lx for y in ly], l)

    sdraw(lx : L SF, ly : L SF) : VIEW2 == sdraw(lx, ly, [])

    sdraw(x : L SF, y : L SF, z : L SF) : VIEW3 == sdraw(x, y, z, [])

    sdraw(x : L SF, y : L SF, z : L SF, l : L DROP) : VIEW3 ==
      m  : Integer := #x
      zero? m => error "No X values"
      n  : Integer := #y
      zero? n => error "No Y values"
      zLen : Integer := #z
      zLen ~= (m*n) =>
        zLen > (m*n) => error "Too many Z-values to fit grid"
        error "Not enough Z-values to fit grid"
      points : L L Pt := []
      for j in n..1 by -1 repeat
        row : L Pt := []
        for i in m..1 by -1 repeat
          zval := (j-1)*m+i
          row := cons(point([x.i, y.j, z.zval, z.zval]), row)
        points := cons(row, points)
      writeViewport3D(mesh points, l)

--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
